/*
Copyright (c) 2011 Pavel Sountsov

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.

*/
#define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_DEBUG

#include <spdlog/spdlog.h>

#include "../widgetz_internal.hpp"

#include "../../macros.hpp"

/*
Title: Public

These are the functions you use to interact with the WidgetZ widgets.
*/

/*
Function: wz_set_shortcut

Sets the shorcut combination for a widget.

Parameters:

keycode - Allegro keycode to use
modifiers - bitfield of modifier flags to match. You can combine multiple flags via binary OR.
*/
void WZ_WIDGET::set_shortcut( int keycode, int modifiers )
{
    shortcut.keycode = keycode;
    shortcut.modifiers = modifiers;
}

/*
Function: wz_register_sources

Registers the widget tree with an Allegro event queue. Now, any event generated by this widget and any
of its children will be registered by it.

Parameters:

queue - Allegro event queue to use
*/
void WZ_WIDGET::register_sources( ALLEGRO_EVENT_QUEUE *queue )
{
    al_register_event_source( queue, source );
    WZ_WIDGET *child = first_child;

    while( child )
    {
        child->register_sources( queue );
        child = child->next_sib;
    }
}

/*
Function: wz_detach

Detaches a widget tree from its parent
*/
void WZ_WIDGET::detach()
{
    if( parent == nullptr )
        return;

    if( next_sib != nullptr )
    {
        if( prev_sib != nullptr )
        {
            prev_sib->next_sib = next_sib;
            next_sib->prev_sib = prev_sib;
        }
        else
        {
            next_sib->prev_sib = nullptr;
            parent->first_child = next_sib;
        }
    }
    else if( prev_sib != nullptr )
    {
        if( next_sib != nullptr )
        {
            next_sib->prev_sib = prev_sib;
            prev_sib->next_sib = next_sib;
        }
        else
        {
            prev_sib->next_sib = nullptr;
            parent->last_child = prev_sib;
        }
    }
    else
    {
        parent->first_child = nullptr;
        parent->last_child = nullptr;
    }

    parent = nullptr;
    next_sib = nullptr;
    prev_sib = nullptr;
}

/*
Function: wz_attach

Attaches a widget tree to its parent
*/
void WZ_WIDGET::attach( WZ_WIDGET *ptr )
{
    if( ptr == nullptr )
        return;

    detach();
    parent = ptr;

    if( parent->last_child != nullptr )
    {
        parent->last_child->next_sib = this;
        prev_sib = parent->last_child;
    }

    if( parent->first_child == nullptr )
        parent->first_child = this;

    parent->last_child = this;
    set_theme( parent->theme );
}

/*
Function: wz_attach_after

Attaches a widget to a parent after a specific widget (the parent is taken from sib)

Parameters:

sib - Widget after which this widget will be attached. It's parent is used as the parent of this widget
*/
void WZ_WIDGET::attach_after( WZ_WIDGET *sib )
{
    if( sib->parent == nullptr )
        return;

    detach();

    if( sib->next_sib )
    {
        sib->next_sib->prev_sib = this;
    }
    else
    {
        sib->parent->last_child = this;
    }

    next_sib = sib->next_sib;
    sib->next_sib = this;
    prev_sib = sib;
    parent = sib->parent;
}

/*
Function: wz_attach_before

Attaches a widget to a parent before a specific widget (the parent is taken from sib)

Parameters:

sib - Widget before which this widget will be attached. It's parent is used as the parent of this widget
*/
void WZ_WIDGET::attach_before( WZ_WIDGET *sib )
{
    if( sib->parent == nullptr )
        return;

    detach();

    if( sib->prev_sib )
    {
        sib->prev_sib->next_sib = this;
    }
    else
    {
        sib->parent->first_child = this;
    }

    prev_sib = sib->prev_sib;
    sib->prev_sib = this;
    next_sib = sib;
    parent = sib->parent;
}

/*
Function: wz_send_event

Sends an event to a widget, and to any of its focused children, propagating down the tree.
The first widget that processes the event breaks the process.
Note that the first widget gets the event whether it is focused or not.

Returns:
1 if the event was handled by some widget, 0 if it was not
*/
auto WZ_WIDGET::send_event( const ALLEGRO_EVENT *event ) -> int
{
    WZ_WIDGET *child = first_child;

    if( proc( event ) )
    {
        return 1;
    }

    while( child )
    {
        if( ( child->flags & WZ_STATE_HAS_FOCUS ) && child->send_event( event ) )
        {
            return 1;
        }

        child = child->next_sib;
    }

    /*
	See if the unfocused ones would like some too
	*/
    child = first_child;

    while( child )
    {
        if( child->send_event( event ) )
        {
            return 1;
        }

        child = child->next_sib;
    }

    return 0;
}

/*
Function: wz_broadcast_event

Broadcasts an event to a widget, and to all of its children, propagating down the tree

Returns:
1 if the event was handled by some widget, 0 if it was not
*/
auto WZ_WIDGET::broadcast_event( const ALLEGRO_EVENT *event ) -> int
{
    int ret = 0;
    WZ_WIDGET *child = first_child;
    ret |= proc( event );

    while( child )
    {
        WZ_WIDGET *next = child->next_sib;
        ret |= child->broadcast_event( event );
        child = next;
    }

    return ret;
}

/*
Function: wz_update

Updates the widget tree, call this every frame
Doesn't update the disabled widgets

Parameters:
dt - Time that has passed since the last update
*/
void WZ_WIDGET::update( double dt )
{
    ALLEGRO_EVENT event;
    wz_craft_event( &event, WZ_UPDATE, nullptr, 0 );
    broadcast_event( &event );
    wz_craft_event( &event, WZ_UPDATE_POSITION, nullptr, 0 );
    broadcast_event( &event );
}

/*
Function: wz_trigger

Triggers a widget. What the widget does depends on the widget. Generally, it will send
an event that is characteristic of the events that it usually sends. For example,
triggering a button will simulate an impression of the button, causing it to send <WZ_BUTTON_PRESSED>
event.
*/
void WZ_WIDGET::trigger()
{
    ALLEGRO_EVENT event;
    wz_craft_event( &event, WZ_TRIGGER, nullptr, 0 );
    send_event( &event );
}

/*
Function: wz_draw

Draws the widget tree. Only affects the visible widgets
*/
void WZ_WIDGET::draw()
{
    ALLEGRO_EVENT event;
    wz_craft_event( &event, WZ_DRAW, nullptr, 0 );
    broadcast_event( &event );
}

/*
Function: wz_set_text

Sets the text of a widget. The widget makes a local copy of the text.
*/
void WZ_WIDGET::set_text( ALLEGRO_USTR *text )
{
    ALLEGRO_EVENT event;
    wz_craft_event( &event, WZ_SET_TEXT, nullptr, (intptr_t)text );
    send_event( &event );
}

/*
Function: wz_show

Shows/hides the widget tree

Parameters:
show - pass 1 to show the widget tree, or 0 to hide it
*/
void WZ_WIDGET::show( int show )
{
    ALLEGRO_EVENT event;
    wz_craft_event( &event, show ? WZ_SHOW : WZ_HIDE, nullptr, 0 );
    broadcast_event( &event );
}

/*
Function: wz_destroy

Destroys the widget tree. Call it to free all of the memory used by the widget tree.
*/
void WZ_WIDGET::destroy()
{
    ALLEGRO_EVENT event;
    detach();
    wz_craft_event( &event, WZ_DESTROY, nullptr, 0 );
    broadcast_event( &event );
}

/*
 Function: wz_resize
 
 Resizes the widget tree. 
 
 Parameters:
 factor: scaling factor
 */
void WZ_WIDGET::resize( float factor )
{
    ALLEGRO_EVENT event;
    wz_craft_event( &event, WZ_RESIZE, nullptr, *(intptr_t *)&factor );
    broadcast_event( &event );
}

/*
Function: wz_enable

Enables/disables the widget tree

Parameters:
enable - pass 1 to enable the widget tree, or 0 to disable it
*/
void WZ_WIDGET::enable( int enable )
{
    ALLEGRO_EVENT event;
    wz_craft_event( &event, enable ? WZ_ENABLE : WZ_DISABLE, nullptr, 0 );
    broadcast_event( &event );
}

/*
Function: wz_focus

Focuses/defocuses the widget tree. This function propagates the focus down the tree.

Parameters:
focus - pass 1 to focus the widget tree, or 0 to defocus it
*/
void WZ_WIDGET::focus( int focus )
{
    if( focus )
    {
        ask_parent_for_focus();
    }
    else
    {
        ALLEGRO_EVENT event;
        wz_craft_event( &event, WZ_LOSE_FOCUS, nullptr, 0 );
        broadcast_event( &event );
    }
}

/*
Function: wz_set_scroll_pos

Sets the scroll position

Parameters:
max - Pass 1 to say that pos is actually the max position, 0 otherwise
*/
void WZ_WIDGET::set_scroll_pos( int pos, int max )
{
    ALLEGRO_EVENT event;
    wz_craft_event( &event, max ? WZ_SET_SCROLL_MAX_POS : WZ_SET_SCROLL_POS, nullptr, pos );
    send_event( &event );
}

/*
Function: wz_set_cursor_pos

Sets the cursor position
*/
void WZ_WIDGET::set_cursor_pos( int pos )
{
    ALLEGRO_EVENT event;
    wz_craft_event( &event, WZ_SET_CURSOR_POS, nullptr, pos );
    send_event( &event );
}

/*
Function: wz_blend_colors

Blends two Allegro colors.

Parameters:
frac - Blending factor. 0 results in the output being the first color passed, 1 results in the second color passed.
Intermediate values blend between the two colors.
*/
auto wz_blend_colors( ALLEGRO_COLOR c1, ALLEGRO_COLOR c2, float frac ) -> ALLEGRO_COLOR
{
    ALLEGRO_COLOR ret;
    ret.a = c1.a + ( c2.a - c1.a ) * frac;
    ret.r = c1.r + ( c2.r - c1.r ) * frac;
    ret.g = c1.g + ( c2.g - c1.g ) * frac;
    ret.b = c1.b + ( c2.b - c1.b ) * frac;
    return ret;
}

/*
Function: wz_scale_color

Tints an Allegro color by multiplying each component by a constant. Alpha is not touched.

Parameters:
scale - Scaling factor. 0 results in a black color, 1 results in no change
*/
auto wz_scale_color( ALLEGRO_COLOR c, float scale ) -> ALLEGRO_COLOR
{
    ALLEGRO_COLOR ret;
    ret.a = c.a;
    ret.r = c.r * scale;
    ret.g = c.g * scale;
    ret.b = c.b * scale;

    if( ret.r > 1 )
        ret.r = 1;

    if( ret.g > 1 )
        ret.g = 1;

    if( ret.b > 1 )
        ret.b = 1;

    return ret;
}

/*
Function: wz_widget_rect_test

Tests if a point is inside the widget

Returns:
1 if the point is inside the widget, 0 otherwise
*/
auto WZ_WIDGET::widget_rect_test( float x, float y ) -> int
{
    return x > local_x && x < local_x + width && y > local_y && y < local_y + height;
}

/*
Function: wz_widget_rect_test_all

Like <wz_widget_rect_test> but traverses the widget tree to see if any of its branches
intersect with the passed coordinates. Hidden widgets are ignored.

Returns:
1 if the point is inside one of the widgets, 0 otherwise
*/
auto WZ_WIDGET::widget_rect_test_all( float x, float y ) -> int
{
    WZ_WIDGET *child;

    if( flags & WZ_STATE_HIDDEN )
        return 0;

    if( widget_rect_test( x, y ) )
        return 1;

    child = first_child;

    while( child )
    {
        int ret = child->widget_rect_test_all( x, y );

        if( ret )
            return 1;

        child = child->next_sib;
    }

    return 0;
}
